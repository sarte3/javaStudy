* 클래스

* 객체

-------------------------------------------------------------
*메소드 : 객체간의 데이터 전달 수단으로 사용

*메소드 선언 문법
[접근제어자] [속성] 리턴유형 메소드명(매개변수리스트){}

-참고
 선언부(메소드 signature라고도 한다) : 리턴유형,메소드명,매개변수리스트
 실행부 : {}블럭안의 코드

*메소드 호출 
문법> 메소드명([매개변수리스트]);


*메소드 종류 
1. 리턴값도 없고, 매개변수도 없는 메소드
문법> void 메소드명(){}
예시> void showMsg(){
			syso("안녕하세요");
     }

2. 리턴값도 없고, 매개변수도 있는 메소드
문법> void 메소드명(매개변수리스트){}
예시> void add(int num1, int num2){
			int result =num1+num2;
			syso( result );
     }

3. 리턴값 있지만, 매개변수도 없는 메소드
문법> 리턴유형 메소드명(){}
예시> int add(){
       int result =1+1;
       return result;
    }

4. 리턴값, 매개변수 있는 메소드
문법> 리턴유형 메소드명(매개변수리스트){}
예시> String upper(String str){   =>오라클의 upper('scott')
	    ....
        return 값;
     }
      
-----------------------------
*return문-교재p258참고
 - return문이 존재하면 현재 실행중인 메서드가 종료되고  
     해당 메서드를 호출한 곳으로 되돌아 간다.   

참고. 메서드가 정상적으로 종료되는 경우
	- 메서드의 블럭{}의 끝에 도달했을 때
	- 메서드의 블럭{}을 수행 도중 return문을 만났을 때
     
참고. 반환값이 없으면 return;				-> ch06.Car05참고
         반환값이 있으면 return 반환값;
-----------------------------
*method overloading - 교재p283참고
 -하나의 클래스에 같은 이름의 메서드를 여러개 정의
 -메서드의 이름이 같아야한다.
 -메서드의 매개변수 타입, 개수, 순서는 달라야 한다.
--------------------------------
*생성자(constructor) - 교재p291참고
 - 모든 클래스에는 반드시 하나 이상의 생성자가 있어야 한다.

*생성자 역할
 - 인스턴스 변수의 초기화. 필드의 초기화(ch06.Korean01 참고)
 - 인스턴스 생성시 수행할 작업에 사용

*문법
 - [접근제어자] 클래스명(매개변수리스트){}
 - 생성자의 이름은 클래스의 이름과 같아야 한다.
 - 생성자는 리턴값이 없다. (하지만 void를 쓰지 않는다.)


*기본생성자 - 교재p292참고
 - [접근제어자] 클래스명(){}
 - 매개변수가 없는 생성자
 - 클래스에 생성자가 하나도 없으면 컴파일러가 기본 생성자를 추가한다.
  (주의.생성자가 하나라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다.)
 
*매개변수가 있는 생성자 - 교재p294참고
 - [접근제어자] 클래스명(매개변수리스트){}
 - 필드의 초기화(ch06.Korean01 참고)

*this() -  교재p295참고, ch06.Car03참고
	- 같은 클래스의 다른 생성자를 호출할 때 사용
  - 주의.
 		반드시 생성자안에서 
 		반드시 첫 번째 문장으로 작성되어야 한다.

--------------------------
*this -  교재p295참고, ch06.Car04참고
	– 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어있음
	- 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재
	
----------------------------
*매개변수의 수를 모를 때- ch06.Computer01참고, ch06.Computer01_ex01참고
			           - 교재 p267 ReferenceParam3.java 참고	
	- 메소드의 매개변수의 수는  메소드선언시 정해져 있는 것이 일반적
	  경우에 따라서는 메소드 선언시   매개변수의 개수를 알 수 없는 경우가 있다
	  예) 합구하기    1+2+3+4+5+6+....
	 해결 방법!   	매개변수를 배열타입으로 선언 
	 
문법1)	[접근제어자]  [속성] 		리턴유형 	메소드명(타입[]  매개변수명){}
문법2)	[접근제어자]  [속성] 		리턴유형 	메소드명(타입... 매개변수명){}
예문)		public  		static	void		main(String[] args){}

*배열생성- 교재189
타입[] (배열)변수명 = new int[크기];	//자동초기화
타입[] (배열)변수명 = {값1,값2,값3};  //값 지정

//메서드 선언
int 	sum(int[] values){}

int[] v = {1,2,3};	
int result   = sum(v); 										//메소드 호출 방법1

int result   = sum(new int[]{10,20,30});  //메소드 호출 방법2
int result   = sum(10,20,30); 					  //메소드 호출 방법3


-----------------------
*정적멤버 - 클래스변수, 클래스메서드(static메서드) 사용
/* -클래스변수 : 같은 클래스의 모든 인스턴스들이 공유하는 변수
 * -클래스메서드 :메서드 내에서 인스턴스변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.
 * 				인스턴스변수나 인스턴스메서드와 관련없는 작업을 하는 메서드

*정적메소드와 블록
----------------------
*final
 - 사전적인 의미로 마지막의, 변경될 수 없는.
 - 클래스,필드,메서드 앞에 선언할 수 있다

*final 필드 - -교재p345참고,ch07.Person01참고

*생성자를 이용한 final 멤버변수 초기화
	-final이 붙은 변수는 상수이므로 보통은 선언과 초기화를 동시에 하지만, 
 	  인스턴스변수의 경우 생성자에서 초기화 할 수 있다.
  
*final 클래스 -교재p345참고, ch07.Ex02참고
 - 하위클래스를 생성하지x  
  
----------------------  
*상수(static final) - 교재p30참고, ch07.Earth_ex01참고
	- 일반적으로  불변의 값을  상수라고 부른다
   	예) 파이, 지구의 둘레 등등
  - 자바에서는  상수(constant)라고 한다 
       공용성을 띈 불변의 값을 상수
    static final 데이터타입  상수명 [=초기값];

-------------------------
*자바8 API
 https://docs.oracle.com/javase/8/docs/api/
 
*참고 API란?
	API(Application Programming Interface, 응용 프로그램 프로그래밍 인터페이스)는 
	응용 프로그램에서 사용할 수 있도록, 
	운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다
-------------------------
*package와 import - 교재 p336참고, ch07.Ex01참고
	-서로 관련된 클래스와 인터페이스의 묶음.
	-클래스의 실제 이름(full name)은 패키지명이 포함
	 예) String클래스의 full name은 java.lang.String

-------------------------
*접근 제어자(access modifier) - 교재 p348,
	-멤버 또는 클래스에 사용되어, 외부로부터의 접근을 제한한다

 public			-	누구나 접근가능
 protected	- 동일클래스,동일패키지,(다른패키지이더라도)상속받은 하위클래스
 default		- 동일클래스,동일패키지
 private		- 동일클래스에서만 접근 가능.
 
*접근 제어자를 이용한 캡슐화 - 교재 p348
	- 접근제어자를 이용하는 이유
		: 선언된 데이터를 보호하기 위함
		: 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
	- 데이터가 유효한 값을 유지하도록, 또는 비번과 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기위해서는
		외부로부터의 접근을 제한하는 것이 필요
		이것을 데이터 감추기(data hiding)라고 하며
		객체지향개념의 캡슐화(encapsulation)에 해당하는 내용이다
 
*생성자의 접근 제어자- 교재 p351, CH07.Singleton참고
	- 일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치한다.
	- 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.
	
 -------------------------
 *상속 - 교재p310, ch07.CellPhone01, DmbCellPhone01, DmbCellPhone_ex01 참고
 	- 기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것.
 	- 두 클래스를 조상과 자손으로 관계를 맺어주는 것
  - 자손은 조상의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)
  - 자손의 멤버개수는 조상보다 적을 수 없다.(같거나 많다.)
  - 공통부분은 조상에서 관리하고 개별부분은 자손에서 관리한다.
  
 
 *super - 교재p330, SupersonicAirPlane,AirPlane,SupersonicAirPlane_ex01 참고
 	– this와 같음. 조상의 멤버와 자신의 멤버를 구별하는 데 사용.
 	참고   this – 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어있음
 						 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재
 						 
 *오버라이딩(overriding) - 교재 p327, ch07.Calculator01, Computer01, Computer01_ex01참고
  override - vt. ‘~위에 덮어쓰다(overwrite).’, ‘~에 우선하다.’
  -조상클래스로부터 상속받은 메서드의 내용을 상속받는 클래스에 맞게 변경하는 것을 오버라이딩이라고 한다
 	
 *오버라이딩의 조건
 	1. 선언부가 같아야 한다.(이름, 매개변수, 리턴타입)
  2. 접근제어자를 좁은 범위로 변경할 수 없다.
  	 -에) 조상의 메서드가 protected라면, 범위가 같거나 넓은 protected나 public으로만 변경할 수 있다.
  3. 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
  
  
  *@ Annotation - 교재p702, ch07.Computer01_ex01참고
  	- 주석처럼 프로그래밍 언어에 영향을 미치지 않으며, 유용한 정보를 제공
  	
  	예)@Override 
  	- 오버라이딩을 올바르게 했는지 컴파일러가 체크하게 한다.
  	
  -------------------------	
 *다형성(polymorphism) - 교재p354, ch07.Computer01_ex01참고
 	- 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것
 		즉, 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는 것이 다형성.
 		
 
 *참조변수의 형변환 - 교재p356, ch11.ArrayList01참고
 
 *매개변수의 다형성 - 교재p367
 *instanceof연산자 - 교재p357
 
 -------------------------
 *추상클래스- 교재p375
 
 -------------------------
 *인터페이스(interface)- 교재p381
 
 -------------------------
 *클래스
 java.util.Scanner- 교재p510
 
 -------------------------
 *컬렉션프레임워크(중요★★★★★)- 교재p578, ch11_CF.ppt
	- 컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식
 	- 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공
 	
 *컬렉션 프레임웍의 핵심 인터페이스- 중요★★★★★	
 *List - 순서유지, 중복허용			예)대기자목록
 *Set	 - 순서유지x, 중복허용x
 *Map  - key,value가 한 쌍으로 구성
 				  순서유지x, key는 중복허용x, value은 중복허용 
 
 Collection인터페이스 - 자손인터페이스 List, Set
 Collections클래스
 
 *ArrayList클래스 - 교재p584, ch11
 *HashSet클래스		- 교재p631, ch11
-------------------------
  <데이터입출력구현>
  *DB연동 - 미리 제공해드린 JDBC 프로그래밍.pdf참고
   CRUD 문법
 
 //각종 필요한 변수선언 - 예)conn, stmt, pstmt, rs, sql
	try {
		//1.드라이버 로딩
		//2.Connection객체얻기
		//3-1.실행객체-PreparedStatement객체,Statement객체
		//3-2.쿼리문실행 - executeUpdate(): insert,update,delete
		//				executeUpdate()의 리턴형태는 int
		//				executeQuery() : select
		//				executeQuery()의 리턴형태는 ResultSet
		//4. 추가작업
	}catch(Exception객체) { /*~~~~ */ }
	finally{   /*5. 사용한 객체는 반납: 객체.close(); */ }
 
-------------------------
*예외처리 -교재p414참고
*예외처리하기 try~catch문	-교재p416
*finally블럭 		   			-교재p434	

*다중catch절   :
 주의. 하위Exception클래스부터 먼저 작성하고
       상위Exception클래스는   뒤에  명시
	
try{
		//코드
		//위험코드
		//위험코드
}catch(하위Exception클래스명 참조변수){
		//예외발생 처리 코드
}catch(상위Exception클래스명 참조변수){
		//예외발생 처리 코드
}catch(Exception클래스명 참조변수){
		//예외발생 처리 코드
}finally{
		//finally 블럭에는
		//catch절에 들어가던 들어가지않던
		//무조건 실행해야하는 코드를 작성한다
		//예) DB연동시의 자원반납  
} 
 
 
 
 
 










	 
       
 






















